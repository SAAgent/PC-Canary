#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
FreeCAD Cylinder with Tilted Rectangular Groove Event Handler (implemented via subtractive box)
Responsible for processing events generated by the hook script and updating evaluation metrics
"""

from typing import Dict, Any, Optional, List

# Event type constants
SCRIPT_INITIALIZED = "script_initialized"
FUNCTION_NOT_FOUND = "function_not_found"
FUNCTION_FOUND = "function_found"
FUNCTION_CALLED = "function_called"
FUNCTION_KEY_WORD_DETECTED = "function_key_word_detected"
ERROR = "error"
HOOK_INSTALLED = "hook_installed"

# Keyword-related constants
CYLINDER_RADIUS = "cylinder_radius"
CYLINDER_HEIGHT = "cylinder_height"
GROOVE_WIDTH = "groove_width"
GROOVE_DEPTH = "groove_depth"
GROOVE_HEIGHT = "groove_height"
GROOVE_ANGLE = "groove_angle"
HAS_GROOVE = "has_groove"

def execute_python_code(code: str, logger: Any) -> Dict[str, Any]:
    """
    Execute Python code and return the results
    
    Args:
        code: Python code to execute
        logger: Logger object
        
    Returns:
        Dict[str, Any]: Execution result
    """
    try:
        # Create a new namespace to execute the code
        namespace = {}
        exec(code, namespace)
        result = namespace.get('result', None)
        
        if result is None:
            logger.warning("Cylinder with tilted rectangular groove object not found")
            return None
            
        # Validate result format
        required_keys = [
            CYLINDER_RADIUS, CYLINDER_HEIGHT,
            GROOVE_WIDTH, GROOVE_DEPTH, GROOVE_HEIGHT, GROOVE_ANGLE, HAS_GROOVE
        ]
        if not all(key in result for key in required_keys):
            logger.error(f"Result missing required keys: {required_keys}")
            return None
            
        return result
    except Exception as e:
        logger.error(f"Error executing Python code: {str(e)}")
        return None

def message_handler(message: Dict[str, Any], logger: Any, task_parameter: Dict[str, Any]) -> Optional[List[Dict[str, Any]]]:
    """
    Process messages received from the hook script
    
    Args:
        message: Frida message object
        logger: Logger object
        task_parameter: Task parameters
        
    Returns:
        Optional[List[Dict[str, Any]]]: List of status updates, or None if no updates
    """
    updates = []
    
    if message.get('type') == 'send' and 'payload' in message:
        payload = message['payload']
        
        if 'event' in payload:
            event_type = payload['event']
            logger.debug(f"Received event: {event_type}")
            
            if event_type == SCRIPT_INITIALIZED:
                logger.info(f"Hook script initialized: {payload.get('message', '')}")
                
            elif event_type == FUNCTION_FOUND:
                logger.info(f"Function found: {payload.get('address', '')}")
                
            elif event_type == FUNCTION_CALLED:
                logger.info(f"Function called: {payload.get('message', '')}")
                # Update first key step status
                updates.append({
                    'status': 'key_step',
                    'index': 1,
                    'name': 'Document saved'
                })
                
            elif event_type == FUNCTION_KEY_WORD_DETECTED:
                # Execute Python code and get results
                code = payload.get('code', '')
                filename = payload.get('filename', '')
                expected_path = task_parameter.get("source_path", "") + task_parameter.get("filename", "")
                logger.info(f"Detected keywords, document path: {filename}, expected document path: {expected_path}")
                
                if filename == expected_path:
                    result = execute_python_code(code, logger)
                    if result:
                        # Check if cylinder with groove parameters match expectations
                        expected_cylinder_radius = task_parameter.get(CYLINDER_RADIUS, 20.0)
                        expected_cylinder_height = task_parameter.get(CYLINDER_HEIGHT, 40.0)
                        expected_groove_width = task_parameter.get(GROOVE_WIDTH, 10.0)
                        expected_groove_depth = task_parameter.get(GROOVE_DEPTH, 5.0)
                        expected_groove_height = task_parameter.get(GROOVE_HEIGHT, 30.0)
                        expected_groove_angle = task_parameter.get(GROOVE_ANGLE, 30.0)

                        actual_cylinder_radius = result[CYLINDER_RADIUS]
                        actual_cylinder_height = result[CYLINDER_HEIGHT]
                        actual_groove_width = result[GROOVE_WIDTH]
                        actual_groove_depth = result[GROOVE_DEPTH]
                        actual_groove_height = result[GROOVE_HEIGHT]
                        actual_groove_angle = result[GROOVE_ANGLE]
                        actual_has_groove = result[HAS_GROOVE]

                        # Log key parameters
                        logger.info(f"Task parameter check: Expected cylinder radius={expected_cylinder_radius}, height={expected_cylinder_height}")
                        logger.info(f"Expected rectangular groove: width={expected_groove_width}, depth={expected_groove_depth}, " + 
                                   f"height={expected_groove_height}, angle={expected_groove_angle}")
                        logger.info(f"Actual parameters: Actual cylinder radius={actual_cylinder_radius}, height={actual_cylinder_height}")
                        logger.info(f"Actual rectangular groove: width={actual_groove_width}, depth={actual_groove_depth}, " +
                                   f"height={actual_groove_height}, angle={actual_groove_angle}, " +
                                   f"has groove: {actual_has_groove}")

                        try:
                            # Try to get the numeric part (handle possible units)
                            actual_cylinder_radius_value = float(str(actual_cylinder_radius).split()[0]) if isinstance(actual_cylinder_radius, str) else float(actual_cylinder_radius)
                            actual_cylinder_height_value = float(str(actual_cylinder_height).split()[0]) if isinstance(actual_cylinder_height, str) else float(actual_cylinder_height)
                            
                            actual_groove_width_value = float(str(actual_groove_width).split()[0]) if isinstance(actual_groove_width, str) else float(actual_groove_width)
                            actual_groove_depth_value = float(str(actual_groove_depth).split()[0]) if isinstance(actual_groove_depth, str) else float(actual_groove_depth)
                            actual_groove_height_value = float(str(actual_groove_height).split()[0]) if isinstance(actual_groove_height, str) else float(actual_groove_height)
                            actual_groove_angle_value = float(str(actual_groove_angle).split()[0]) if isinstance(actual_groove_angle, str) else float(actual_groove_angle)
                            
                            # Allow a certain error range (0.01%)
                            cylinder_radius_error = abs((actual_cylinder_radius_value - expected_cylinder_radius) / expected_cylinder_radius) <= 0.0001
                            cylinder_height_error = abs((actual_cylinder_height_value - expected_cylinder_height) / expected_cylinder_height) <= 0.0001
                            
                            groove_width_error = abs((actual_groove_width_value - expected_groove_width) / expected_groove_width) <= 0.0001
                            groove_depth_error = abs((actual_groove_depth_value - expected_groove_depth) / expected_groove_depth) <= 0.0001
                            groove_height_error = abs((actual_groove_height_value - expected_groove_height) / expected_groove_height) <= 0.0001
                            # For angle, allow a certain absolute error (1.0 degree)
                            groove_angle_error = abs(actual_groove_angle_value - expected_groove_angle) <= 1.0
                            
                            has_groove_correct = actual_has_groove
                        except Exception as e:
                            logger.error(f"Error comparing parameters: {str(e)}")
                            cylinder_radius_error = False
                            cylinder_height_error = False
                            groove_width_error = False
                            groove_depth_error = False
                            groove_height_error = False
                            groove_angle_error = False
                            has_groove_correct = False
                        
                        cylinder_correct = cylinder_radius_error and cylinder_height_error
                        groove_correct = (groove_width_error and groove_depth_error and
                                        groove_height_error and groove_angle_error and
                                        has_groove_correct)
                        
                        if cylinder_correct and groove_correct:
                            # Update second key step status
                            updates.append({
                                'status': 'key_step',
                                'index': 2,
                                'name': 'Created cylinder with tilted rectangular groove and saved successfully'
                            })
                            
                            # Task completed successfully
                            updates.append({
                                'status': 'success',
                                'reason': 'Successfully created a cylinder with tilted rectangular groove that meets requirements and saved it'
                            })
                        else:
                            logger.warning(f"Parameter validation failed: " + 
                                          f"Cylinder correct: {cylinder_correct}, " +
                                          f"Rectangular groove correct: {groove_correct}")
                
            elif event_type == ERROR:
                error_type = payload.get("error_type", "unknown")
                error_message = payload.get("message", "Unknown error")
                
                logger.error(f"Hook script error ({error_type}): {error_message}")
                
                # Record error event
                updates.append({
                    'status': 'error',
                    'type': error_type,
                    'message': error_message
                })
                
    elif message.get('type') == 'error':
        logger.error(f"Hook script error: {message.get('stack', '')}")
        
        # Record error event
        updates.append({
            'status': 'error',
            'type': 'script_error',
            'message': message.get('stack', 'Unknown error')
        })
    
    return updates if updates else None
