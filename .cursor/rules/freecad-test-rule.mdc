---
description: 
globs: 
alwaysApply: false
---
# FreeCAD测试任务规则

这个任务需要完成config hooker.js handle.py三个文件，文件放在项目文件夹下的`tests/tasks/${appname}/task(task_id)_${task_name}/`文件夹下，下面是文件的要求
你可以参考`tests/tasks/FreeCAD/task02_save_doc`已完成的任务，虽然可以参考，但是不再使用的函数可以不再生成，如果你认为有必要也可以添加其他的辅助函数

## config.json
对于每一个任务都需要提供一个config.json文件来对任务提供配置，下面是对config.json中应该包含哪些内容所作的说明：
``` json
{
    "task_id": "01",    # 在所属app中的任务序号，必要
    "task_name": "update_color_theme",    # 任务的名称，必要
    "description": "在vscode中修改颜色主题",    # 任务的简要描述，必要

    "application_info": {    # app的信息，必要
        "name": "vscode",    # app的名称，必要
        "executable_path": "apps/VSCode-linux-x64/code-oss",# app的可执行文件路径，必要
        "args": ["--no-sandbox", "--user-data-dir=apps/vscode_user_data_dir/"]
        # app运行的参数，列表可以为空，非必要，默认无参数
    },

    "task_parameters": {    # 任务的默认参数设置，必要
        "theme": "Default Light+"
        # ...
        # 具体的参数名称和值，用于在handler.py的message_handler中核对，必要
    },

    "instruction_template": "在vscode中修改颜色主题为 ${theme}",
    # 任务的具体指令（demo 中后续会直接提供给agent）必要

    "evaluation_setup": {    # 评估器的相关配置，必要
        "scripts": [    # 脚本的相关信息，必要
            { "role": "hook",    "path": "hooker.js" },
            { "role": "handler", "path": "handler.py" }
        ],
        "timeout": 120,    # 等待时延
        "evaluator_type": "IpcInjector",
        # 设置评估器的类型，目前有三类评估器，分别为IpcInjector、HookManager、StateInspector
        # 非必要，如果不设置默认使用HookManager
        "evaluate_on_completion": true
        # 对于某些任务来说需要在agent执行之后，再通过检查数据库、app状态来判断任务是否执行成功，
        # 这些任务需要设置成为true，不需要可以不包含这个参数，默认为false，不必要
        # 另外需要注意目前只有ElectronInjector实现了这个feature，而且你需要在hooker.js里面预留一个名为evaluate的socket事件
        # 可以参考commit
    },
    "success_conditions": [    # 任务完成需要触发的所有核心事件，必要
        "theme_changed",
        # ...
    ],
    "events": {
        "theme_changed": "主题颜色发生了改变"
    }
    # hooker.js中定义的全部事件，对应于handler.py的message_handler中处理的事件，必要
}
```

## hooker.js
hooker.js文件包含了在app注入代码的逻辑：
这里使用frida的js api
目前的设计是把判断任务是否完成的逻辑放到handler.py里，所以hooker.js的作用可以描述为"收集app内事件的信息、数据库的信息、app的状态等等"，然后在handler.py里判断是否符合预期（因为参数需要支持随机化）

对于frida hook方式来说，注入的代码是用来hook某些特定的函数，如果app触发了这些函数调用就可以使用frida提供的send接口向评估器发送消息，最终就会调用到handler.py里的message_handler函数处理，比如：
``` javascript
// shotcut创建新项目监控钩子脚本
// 用于监听shotcut的创建新项目操作并检测任何查询

(function() {
    // 脚本常量设置
  const FUNTION_NAME = "_ZN3App11Application11newDocumentEPKcS2_bb"
  const ORIGIN_FUNTION_NAME = "Application::newDocument"
  const FUNTION_BEHAVIOR = "创建新文档"

  const SCRIPT_INITIALIZED = "script_initialized"
  const FUNTION_NOT_FOUND = "function_not_found"
  const FUNTION_FOUND = "function_found"
  const FUNTION_CALLED = "function_called"
  const FUNTION_KEY_WORD_DETECTED = "funtion_key_word_detected"
  const ERROR = "error"
  const HOOK_INSTALLED = "hook_installed"

  const APP_NAME = "FreeCAD"
  
  // 全局变量
  let funcFound = false;
  
  // 向评估系统发送事件
  function sendEvent(eventType, data = {}) {
      const payload = {
          event: eventType,
          ...data,
          timestamp: new Date().getTime()
      };
      send(payload);
  }
  
  // 查找MainWindow::newProject函数
  function getFunction() {
    // 尝试直接通过导出符号查找
      let FuncAddr = DebugSymbol.getFunctionByName(FUNTION_NAME);
      
    // 如果没找到，报错
      if (!FuncAddr) {
          sendEvent("error", {
              error_type: FUNTION_NOT_FOUND,
              message: `无法找到${ORIGIN_FUNTION_NAME}函数`
          });
          return null;
      }
      
    // 报告找到函数
      funcFound = true;
      sendEvent(FUNTION_FOUND, {
          address: FuncAddr.toString(),
          message: `找到${ORIGIN_FUNTION_NAME}函数`
      });
      
      return FuncAddr;
  }
  
  // 读取C++标准字符串内容
  function readCXXStdString(Ptr) {
      const str_ptr = Ptr;
      const len = str_ptr.add(0x8).readU64();
      const str = str_ptr.readPointer().readCString(len)
      return str;
  }
    
  // 初始化钩子并立即执行
  function initHook() {
      sendEvent(SCRIPT_INITIALIZED, {
          message: `${APP_NAME}${FUNTION_BEHAVIOR}监控脚本已启动`
      });
      
    // 查找搜索函数
      const funcAddr = getFunction();
      if (!funcAddr) {
          return;
      }
      
    // 安装搜索函数钩子
      Interceptor.attach(funcAddr, {
          onEnter: function(args) {
              try {
                  sendEvent(FUNTION_CALLED, {
                      message: `拦截到${FUNTION_BEHAVIOR}函数调用`
                  });
              } catch (error) {
                  sendEvent(ERROR, {
                      error_type: "general_error",
                      message: `执行错误: ${error.message}`
                  });
              }
          },

          onLeave: function(retval) {
              try {
                let Label = retval.add(0xB8)
                let FileName = Label.add(0x60)

                let LabelCXXStringPtr = Label.add(0x40)
                let FileNameCXXStringPtr = FileName.add(0x40)

                Label = readCXXStdString(LabelCXXStringPtr)
                FileName = readCXXStdString(FileNameCXXStringPtr)
                  sendEvent(FUNTION_KEY_WORD_DETECTED, {
                      message: `检测到${FUNTION_BEHAVIOR}操作`,
                label: Label,
                filename: FileName
                  });
                // 检测关键字
                
              } catch (error) {
                  sendEvent(ERROR, {
                      error_type: "general_error",
                      message: `执行错误: ${error.message}`
                  });
              }
          }
      });
      
      sendEvent(HOOK_INSTALLED, {
          message: `钩子安装完成，等待${FUNTION_BEHAVIOR}操作...`
      });
  }
  
  // 立即执行钩子初始化
  initHook();
})();
```
比较关键的内容是，你需要通过项目文件夹中`apps/${app_name}/`文件夹中的代码源文件去搜索相关的函数，然后项目文件夹下`app_symbol`,`gui_symbol`,`symbols`三个文件中找到对应的编译器修饰过的函数名用来`FUNTION_NAME`赋值，并且找到函数调用中的关键字通过`send_event`发送出去给handle.py使用

另外
```
  const SCRIPT_INITIALIZED = "script_initialized"
  const FUNTION_NOT_FOUND = "function_not_found"
  const FUNTION_FOUND = "function_found"
  const FUNTION_CALLED = "function_called"
  const FUNTION_KEY_WORD_DETECTED = "funtion_key_word_detected"
  const ERROR = "error"
  const HOOK_INSTALLED = "hook_installed"

  const APP_NAME = "FreeCAD"
```
这些内容请不要改动

## handler.py
主要需要实现message_handler函数，接收从hooker.js发送来的数据，和config.json中的task_parameters对比，判断是否符合预期。如果需要，也可以在文件设置全局变量来保存异步信息。
文件一个大概的模板如下，高亮部分是需要填充的内容（两处）：

``` python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
事件处理器
负责处理钩子脚本产生的事件并更新评估指标
"""

import os
import json
import time
from typing import Dict, Any, Optional, Callable

# 全局评估器实例，由message_handler使用
_EVALUATOR = None
_CONFIG = None
_START_TIME = None

def set_evaluator(evaluator):
    """设置全局评估器实例"""
    global _EVALUATOR, _CONFIG
    _EVALUATOR = evaluator
    
    # 使用评估器的已更新配置，而不是重新读取文件
    if hasattr(evaluator, 'config') and evaluator.config:
        _CONFIG = evaluator.config
        _EVALUATOR.logger.info("使用评估器中的更新配置")
    else:
        # 作为备份，如果评估器中没有配置，才从文件读取
        try:
            current_dir = os.path.dirname(os.path.abspath(__file__))
            config_file = os.path.join(current_dir, "config.json")
            
            with open(config_file, 'r') as f:
                _CONFIG = json.load(f)
                _EVALUATOR.logger.info("从文件加载配置")
        except Exception as e:
            if _EVALUATOR:
                _EVALUATOR.logger.error(f"加载配置文件失败: {str(e)}")
            # 提供一个默认配置以避免空引用
            _CONFIG = {"task_parameters": {
                ...
            }}

def message_handler(message: Dict[str, Any], data: Any) -> Optional[str]:
    """
    处理从钩子脚本接收的消息
    
    Args:
        message: injector消息对象
        data: 附加数据
        
    Returns:
        str: 如果任务成功完成返回"success"，否则返回None
    """
    global _EVALUATOR, _CONFIG, _START_TIME
    
    # 初始化开始时间
    if _START_TIME is None:
        _START_TIME = time.time()
    
    # 检查评估器是否已设置
    if _EVALUATOR is None:
        print("警告: 评估器未设置，无法处理消息")
        return None
    
    # ...判断message中的数据是否符合预期
    # 如果符合预期，返回success:
        # _EVALUATOR.update_metric("success", True)
        # update time
        # completion_time = time.time() - _START_TIME
        # _EVALUATOR.update_metric("time_to_complete", completion_time)
        # _EVALUATOR.logger.info(f"任务成功完成! 耗时: {completion_time:.2f} 秒")
        # return "success"
    return None

def register_handlers(evaluator):
    """
    注册所有事件处理函数到评估器
    
    Args:
        evaluator: 评估器实例
        
    Returns:
        message_handler: 处理函数
    """
    # 设置全局评估器，用于message_handler
    set_evaluator(evaluator)
    return message_handler
```

## 测试指令格式
```bash
python run_evaluator.py --app FreeCAD --task task03_open_doc --app-path /usr/local/bin/FreeCAD --custom-params '{"source_path":"/FreeCAD/","filename":"task03.FCStd"}'
```

## 注意事项
1. 函数名（FUNTION_NAME）需要从项目文件夹下的`app_symbol`、`gui_symbol`、`symbols`三个文件中找到对应的编译器修饰过的函数名
2. 在hooker.js中，需要根据函数参数正确获取文件名等信息
3. 在handler.py中，需要正确验证文件路径和存在性
4. 所有事件名称需要与config.json中的events字段保持一致
5. 测试时需要确保文件路径正确且文件存在
